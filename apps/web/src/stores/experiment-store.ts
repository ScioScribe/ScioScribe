/**
 * Experiment Store - Zustand
 * 
 * This store manages all experiment-related state and actions,
 * providing a centralized state management solution for the application.
 */

// @ts-ignore - Zustand will be available after npm install
import { create } from 'zustand'
import type { Experiment } from '@/api/database'
import { 
  getExperiments, 
  createExperiment as createExperimentAPI, 
  updateExperimentPlan, 
  updateExperimentHtml, 
  updateExperimentTitle as updateExperimentTitleAPI 
} from '@/api/database'
import { IRIS_CSV_DATA, IRIS_EXPERIMENT_PLAN } from '@/data/placeholder'

// Planning state conversion utility
const convertPlanningStateToString = (planningState: any): string => {
  try {
    if (!planningState) return ""
    
    const timestamp = new Date().toISOString()
    let formattedPlan = `# Experiment Planning Session\n\n*Generated: ${timestamp}*\n\n`
    
    // Add experiment metadata
    if (planningState.experiment_id) {
      formattedPlan += `**Experiment ID:** ${planningState.experiment_id}\n`
    }
    
    if (planningState.current_stage) {
      formattedPlan += `**Current Stage:** ${planningState.current_stage}\n`
    }
    
    formattedPlan += `\n---\n\n`
    
    // Add objective if available
    if (planningState.objective) {
      formattedPlan += `## Objective\n\n${planningState.objective}\n\n`
    }
    
    // Add research query if available
    if (planningState.research_query) {
      formattedPlan += `## Research Query\n\n${planningState.research_query}\n\n`
    }
    
    // Add methodology if available
    if (planningState.methodology) {
      formattedPlan += `## Methodology\n\n${planningState.methodology}\n\n`
    }
    
    // Add variables if available
    if (planningState.variables) {
      formattedPlan += `## Variables\n\n`
      
      if (planningState.variables.independent) {
        formattedPlan += `**Independent Variables:**\n${planningState.variables.independent}\n\n`
      }
      
      if (planningState.variables.dependent) {
        formattedPlan += `**Dependent Variables:**\n${planningState.variables.dependent}\n\n`
      }
      
      if (planningState.variables.controlled) {
        formattedPlan += `**Controlled Variables:**\n${planningState.variables.controlled}\n\n`
      }
    }
    
    // Add design if available
    if (planningState.design) {
      formattedPlan += `## Experimental Design\n\n${planningState.design}\n\n`
    }
    
    // Add data requirements if available
    if (planningState.data_requirements) {
      formattedPlan += `## Data Requirements\n\n${planningState.data_requirements}\n\n`
    }
    
    // Add analysis plan if available
    if (planningState.analysis_plan) {
      formattedPlan += `## Analysis Plan\n\n${planningState.analysis_plan}\n\n`
    }
    
    // Add chat history if available
    if (planningState.chat_history && planningState.chat_history.length > 0) {
      formattedPlan += `## Planning Session History\n\n`
      
      planningState.chat_history.forEach((message: any, index: number) => {
        const messagePrefix = message.sender === "user" ? "🧑" : "🤖"
        formattedPlan += `${index + 1}. ${messagePrefix} **${message.sender}**: ${message.content}\n\n`
      })
    }
    
    // Add completion status
    if (planningState.is_complete) {
      formattedPlan += `## Status\n\n✅ **Planning Complete**\n\n`
    } else {
      formattedPlan += `## Status\n\n🔄 **Planning In Progress**\n\n`
    }
    
    // Add approvals if available
    if (planningState.approvals) {
      formattedPlan += `## Approvals\n\n`
      Object.entries(planningState.approvals).forEach(([stage, approved]) => {
        const status = approved ? "✅" : "❌"
        formattedPlan += `- ${stage}: ${status}\n`
      })
      formattedPlan += `\n`
    }
    
    formattedPlan += `---\n\n*This plan was generated by the AI Planning Agent*`
    
    return formattedPlan
  } catch (error) {
    console.error("❌ Error converting planning state to string:", error)
    return `# Planning State Conversion Error\n\nFailed to convert planning state to string: ${error instanceof Error ? error.message : 'Unknown error'}\n\n**Raw State:**\n\`\`\`json\n${JSON.stringify(planningState, null, 2)}\n\`\`\``
  }
}

// Array to CSV conversion utility
const convertArrayToCsv = (data: any[]): string => {
  try {
    if (!data || data.length === 0) return ""
    
    // Get headers from first object
    const headers = Object.keys(data[0])
    
    // Create CSV content
    let csvContent = headers.join(',') + '\n'
    
    // Add data rows
    data.forEach(row => {
      const values = headers.map(header => {
        const value = row[header]
        // Escape commas and quotes in values
        if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
          return `"${value.replace(/"/g, '""')}"`
        }
        return value || ''
      })
      csvContent += values.join(',') + '\n'
    })
    
    return csvContent
  } catch (error) {
    console.error("❌ Error converting array to CSV:", error)
    return ""
  }
}

interface ExperimentState {
  // Core state
  currentExperiment: Experiment | null
  experiments: Experiment[]
  isLoading: boolean
  
  // Content state
  experimentTitle: string
  editorText: string
  csvData: string
  visualizationHtml: string
}

interface ExperimentActions {
  // Core actions
  setLoading: (isLoading: boolean) => void
  setExperiments: (experiments: Experiment[]) => void
  setCurrentExperiment: (experiment: Experiment | null) => void
  
  // Content actions
  setExperimentTitle: (title: string) => void
  setEditorText: (text: string) => void
  setCsvData: (csv: string) => void
  setVisualizationHtml: (html: string) => void
  
  // Complex actions with side effects
  loadExperiments: () => Promise<void>
  createFirstExperiment: () => Promise<void>
  selectExperiment: (experiment: Experiment) => void
  updateEditorTextWithSave: (text: string) => Promise<void>
  updateVisualizationHtmlWithSave: (html: string) => Promise<void>
  updateExperimentTitleWithSave: (title: string) => Promise<void>
  refreshVisualization: () => void
  
  // Planning integration functions
  updatePlanFromPlanningState: (planningState: any) => Promise<void>
  updatePlanFromPlanningMessage: (message: string, stage?: string) => Promise<void>
  
  // Dataclean integration functions
  updateCsvFromDatacleanResponse: (response: any) => Promise<void>
  updateCsvFromDatacleanData: (csvData: string) => Promise<void>
  
  // Reset actions
  resetState: () => void
}

type ExperimentStore = ExperimentState & ExperimentActions

// Type definitions for Zustand
type SetState = (partial: Partial<ExperimentStore> | ((state: ExperimentStore) => Partial<ExperimentStore>)) => void
type GetState = () => ExperimentStore

const initialState: ExperimentState = {
  currentExperiment: null,
  experiments: [],
  isLoading: true,
  experimentTitle: "Untitled Experiment",
  editorText: IRIS_EXPERIMENT_PLAN,
  csvData: IRIS_CSV_DATA,
  visualizationHtml: "",
}

export const useExperimentStore = create<ExperimentStore>((set: SetState, get: GetState) => ({
  ...initialState,
  
  // Basic setters
  setLoading: (isLoading: boolean) => 
    set({ isLoading }),
  
  setExperiments: (experiments: Experiment[]) => 
    set({ experiments }),
  
  setCurrentExperiment: (currentExperiment: Experiment | null) => 
    set({ currentExperiment }),
  
  setExperimentTitle: (experimentTitle: string) => 
    set({ experimentTitle }),
  
  setEditorText: (editorText: string) => 
    set({ editorText }),
  
  setCsvData: (csvData: string) => 
    set({ csvData }),
  
  setVisualizationHtml: (visualizationHtml: string) => 
    set({ visualizationHtml }),
  
  // Complex actions with side effects
  loadExperiments: async () => {
    set({ isLoading: true })
    try {
      const data = await getExperiments()
      set({ experiments: data })
      
      // If experiments exist, load the first one
      if (data.length > 0) {
        get().selectExperiment(data[0])
      }
    } catch (error) {
      console.error("Failed to load experiments:", error)
    } finally {
      set({ isLoading: false })
    }
  },
  
  // Planning integration functions
  updatePlanFromPlanningState: async (planningState: any) => {
    try {
      console.log("🎯 Updating plan from planning state:", planningState)
      
      // Convert planning state to formatted string
      const formattedPlan = convertPlanningStateToString(planningState)
      
      // Update the editor text (this will also save to database)
      await get().updateEditorTextWithSave(formattedPlan)
      
      console.log("✅ Plan updated from planning state")
    } catch (error) {
      console.error("❌ Failed to update plan from planning state:", error)
    }
  },
  
  updatePlanFromPlanningMessage: async (message: string, stage?: string) => {
    try {
      console.log("📝 Updating plan from planning message:", message)
      
      const currentPlan = get().editorText
      const timestamp = new Date().toISOString()
      
      // Append planning message to current plan
      const updatedPlan = `${currentPlan}\n\n## Planning Session Update - ${timestamp}\n\n${stage ? `**Stage:** ${stage}\n\n` : ""}${message}\n\n---\n`
      
      // Update the editor text (this will also save to database)
      await get().updateEditorTextWithSave(updatedPlan)
      
      console.log("✅ Plan updated from planning message")
    } catch (error) {
      console.error("❌ Failed to update plan from planning message:", error)
    }
  },
   
   // Dataclean integration functions
   updateCsvFromDatacleanResponse: async (response: any) => {
     try {
       console.log("🧹 Updating CSV from dataclean response:", response)
       
       // Extract CSV data from response
       let csvData = ""
       
       if (response.data) {
         if (typeof response.data === "string") {
           csvData = response.data
         } else if (Array.isArray(response.data)) {
           // Convert array of objects to CSV
           csvData = convertArrayToCsv(response.data)
         } else {
           console.warn("⚠️ Unexpected data format in dataclean response")
           csvData = JSON.stringify(response.data, null, 2)
         }
       }
       
       if (csvData) {
         await get().updateCsvFromDatacleanData(csvData)
       }
       
       console.log("✅ CSV updated from dataclean response")
     } catch (error) {
       console.error("❌ Failed to update CSV from dataclean response:", error)
     }
   },
   
   updateCsvFromDatacleanData: async (csvData: string) => {
     try {
       console.log("📊 Updating CSV from dataclean data")
       
       // Update the CSV data in the store
       set({ csvData })
       
       // Auto-save to database if experiment is selected
       const { currentExperiment } = get()
       if (currentExperiment) {
         try {
           // Note: We need to create an updateExperimentCsv function in the database API
           // For now, we'll log that this needs to be implemented
           console.log("🔄 CSV data updated in store, database update would happen here")
           // await updateExperimentCsv(currentExperiment.id, csvData)
         } catch (error) {
           console.error("Failed to update CSV in database:", error)
         }
       }
       
       console.log("✅ CSV updated from dataclean data")
     } catch (error) {
       console.error("❌ Failed to update CSV from dataclean data:", error)
     }
   },

   createFirstExperiment: async () => {
     try {
       const newExperiment = await createExperimentAPI({
         title: "Untitled Experiment",
         experimental_plan: IRIS_EXPERIMENT_PLAN,
         csv_data: IRIS_CSV_DATA,
         visualization_html: ""
       })
       
       // Reload experiments and select the new one
       await get().loadExperiments()
       get().selectExperiment(newExperiment)
     } catch (error) {
       console.error("Failed to create experiment:", error)
     }
   },
  
  selectExperiment: (experiment: Experiment) => {
    console.log("Selected experiment:", experiment)
    
    set({
      currentExperiment: experiment,
      experimentTitle: experiment.title || "Untitled Experiment",
      editorText: experiment.experimental_plan || IRIS_EXPERIMENT_PLAN,
      csvData: experiment.csv_data || IRIS_CSV_DATA,
      visualizationHtml: experiment.visualization_html || "",
    })
  },
  
  updateEditorTextWithSave: async (text: string) => {
    set({ editorText: text })
    
    // Auto-save to database if experiment is selected
    const { currentExperiment } = get()
    if (currentExperiment) {
      try {
        await updateExperimentPlan(currentExperiment.id, text)
        console.log("Plan updated in database")
      } catch (error) {
        console.error("Failed to update plan:", error)
      }
    }
  },
  
  updateVisualizationHtmlWithSave: async (html: string) => {
    set({ visualizationHtml: html })
    
    // Auto-save to database if experiment is selected
    const { currentExperiment } = get()
    if (currentExperiment) {
      try {
        await updateExperimentHtml(currentExperiment.id, html)
        console.log("Visualization updated in database")
      } catch (error) {
        console.error("Failed to update visualization:", error)
      }
    }
  },
  
  updateExperimentTitleWithSave: async (title: string) => {
    set({ experimentTitle: title })
    
    // Auto-save to database if experiment is selected
    const { currentExperiment, experiments } = get()
    if (currentExperiment) {
      try {
        const updatedExperiment = await updateExperimentTitleAPI(currentExperiment.id, title)
        
        // Update the current experiment with the new title
        set({ currentExperiment: updatedExperiment })
        
        // Update the experiments array to reflect the new title
        const updatedExperiments = experiments.map((exp: Experiment) => 
          exp.id === currentExperiment.id 
            ? { ...exp, title: title, updated_at: updatedExperiment.updated_at }
            : exp
        )
        set({ experiments: updatedExperiments })
        
        console.log("Title updated in database")
      } catch (error) {
        console.error("Failed to update title:", error)
      }
    }
  },
  
  refreshVisualization: () => {
    set({ visualizationHtml: "" })
  },
  
  resetState: () => {
    set(initialState)
  },
})) 